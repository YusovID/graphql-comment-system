package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"graphql-comment-system/graph/model"
	"time"

	"github.com/google/uuid"
)

// Post is the resolver for the post field.
func (r *commentResolver) Post(ctx context.Context, obj *model.Comment) (*model.Post, error) {
	post, err := r.Resolver.PostStore.GetPostByID(ctx, obj.PostID)
	if err != nil {
		return nil, fmt.Errorf("post with id %s not found: %w", obj.PostID, err)
	}
	return post, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	//TODO: Implement validation

	post := &model.Post{
		ID:            uuid.NewString(),
		Author:        input.Author,
		Content:       input.Content,
		Title:         input.Title,
		CreatedAt:     time.Now().Format(time.RFC3339),
		AllowComments: input.AllowComments,
	}
	r.Resolver.PostStore.AddPost(ctx, post)
	return post, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.CreateCommentInput) (*model.Comment, error) {
	//TODO: Implement validation

	comment := &model.Comment{
		ID:        uuid.NewString(),
		Author:    input.Author,
		Content:   input.Content,
		PostID:    input.PostID,
		CreatedAt: time.Now().Format(time.RFC3339),
	}
	r.Resolver.CommentStore.AddComment(ctx, comment)
	return comment, nil
}

// Comments is the resolver for the comments field.
func (r *postResolver) Comments(ctx context.Context, obj *model.Post, first *int32, after *string) (*model.CommentConnection, error) {
	var n = int32(10)
	if first != nil {
		n = int32(*first)
	}
	result, err := r.Resolver.CommentStore.GetCommentsForPost(ctx, obj.ID, n, after)
	if err != nil {
		return nil, err
	}

	var edges []*model.CommentEdge
	for _, comment := range result.Comments {
		edges = append(edges, &model.CommentEdge{
			Cursor: comment.ID,
			Node:   comment,
		})
	}

	pageInfo := &model.PageInfo{
		HasNextPage: result.HasNextPage,
		StartCursor: &edges[0].Cursor,
		EndCursor:   &edges[len(edges)-1].Cursor,
	}

	return &model.CommentConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	post, err := r.Resolver.PostStore.GetPostByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get post by id: %w", err)
	}
	return post, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, first *int32, after *string) (*model.PostConnection, error) {
	var firstValue int32 = 10
	if first != nil {
		firstValue = int32(*first)
	}

	result, err := r.Resolver.PostStore.GetPosts(ctx, firstValue, after)
	if err != nil {
		return nil, fmt.Errorf("get posts: %w", err)
	}

	postEdges := make([]*model.PostEdge, len(result.Posts))
	for i, post := range result.Posts {
		postEdges[i] = &model.PostEdge{
			Cursor: post.ID,
			Node:   post,
		}
	}

	var hasPreviousPage bool
	if after != nil {
		hasPreviousPage = true
	} else {
		hasPreviousPage = false
	}

	var startCursor, endCursor *string
	if len(postEdges) > 0 {
		startCursor = &postEdges[0].Cursor
		endCursor = &postEdges[len(postEdges)-1].Cursor
	}

	pageInfo := &model.PageInfo{
		HasNextPage:     result.HasNextPage,
		HasPreviousPage: hasPreviousPage,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}

	return &model.PostConnection{
		Edges:    postEdges,
		PageInfo: pageInfo,
	}, nil
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, id string) (*model.Comment, error) {
	comment, err := r.Resolver.CommentStore.GetCommentByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get comment by id: %w", err)
	}
	return comment, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
