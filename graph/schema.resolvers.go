package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"graphql-comment-system/graph/model"
	inmemory "graphql-comment-system/pkg/data/in-memory"
	"graphql-comment-system/pkg/validator"
	"strings"
	"time"
)

// Post is the resolver for the post field.
func (r *commentResolver) Post(ctx context.Context, obj *model.Comment) (*model.Post, error) {
	post, err := r.Resolver.PostStore.GetPostByID(ctx, obj.PostID)
	if err != nil {
		return nil, fmt.Errorf("post with id %s not found: %w", obj.PostID, err)
	}
	return post, nil
}

// Replies is the resolver for the replies field.
func (r *commentResolver) Replies(ctx context.Context, obj *model.Comment, first *int32, after *string) (*model.CommentConnection, error) {
	var n = int32(10)
	if first != nil {
		n = int32(*first)
	}
	result, err := r.Resolver.CommentStore.GetRepliesForComment(ctx, obj.ID, n, after) // Используем новую функцию GetRepliesForComment
	if err != nil {
		return nil, err
	}

	var edges []*model.CommentEdge
	for _, edge := range result.Edges {
		edges = append(edges, &model.CommentEdge{
			Cursor: edge.Cursor,
			Node:   edge.Node,
		})
	}

	pageInfo := &model.PageInfo{
		HasNextPage: result.PageInfo.HasNextPage,
		StartCursor: func() *string {
			if len(edges) > 0 {
				return &edges[0].Cursor
			}
			return nil
		}(),
		EndCursor: func() *string {
			if len(edges) > 0 {
				return &edges[len(edges)-1].Cursor
			}
			return nil
		}(),
	}

	return &model.CommentConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	// Валидация входных данных
	validationErrors := validator.ValidateCreatePostInput(ctx, input.Title, input.Author, input.Content)
	if len(validationErrors) > 0 {
		var errorMessages []string
		for _, err := range validationErrors {
			errorMessages = append(errorMessages, err.Error())
		}
		return nil, fmt.Errorf("validation errors: %s", strings.Join(errorMessages, "; "))
	}

	post := &model.Post{
		//TODO: Use UUIDs for IDs

		ID:            inmemory.GetNextPostID(),
		Author:        input.Author,
		Content:       input.Content,
		Title:         input.Title,
		CreatedAt:     time.Now().Format(time.RFC3339),
		AllowComments: input.AllowComments,
	}
	r.Resolver.PostStore.AddPost(ctx, post)
	return post, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.CreateCommentInput) (*model.Comment, error) {
	// Валидация входных данных
	validationErrors := validator.ValidateCreateCommentInput(r.PostStore, r.CommentStore, ctx, input.Author, input.Content, input.PostID, input.ParentID)
	if len(validationErrors) > 0 {
		var errorMessages []string
		for _, err := range validationErrors {
			errorMessages = append(errorMessages, err.Error())
		}
		return nil, fmt.Errorf("validation errors: %s", strings.Join(errorMessages, "; "))
	}

	comment := &model.Comment{
		//TODO: Use UUIDs for IDs
		ID:        inmemory.GetNextCommentID(),
		Author:    input.Author,
		Content:   input.Content,
		PostID:    input.PostID,
		CreatedAt: time.Now().Format(time.RFC3339),
	}

	if input.ParentID != nil {
		comment.ParentID = input.ParentID
	}

	r.Resolver.CommentStore.AddComment(ctx, comment)
	return comment, nil
}

// Comments is the resolver for the comments field.
func (r *postResolver) Comments(ctx context.Context, obj *model.Post, first *int32, after *string) (*model.CommentConnection, error) {
	var n = int32(10)
	if first != nil {
		n = int32(*first)
	}
	result, err := r.Resolver.CommentStore.GetCommentsForPost(ctx, obj.ID, n, after)
	if err != nil {
		return nil, err
	}

	var edges []*model.CommentEdge
	for _, edge := range result.Edges {
		edges = append(edges, &model.CommentEdge{
			Cursor: edge.Cursor,
			Node:   edge.Node,
		})
	}

	pageInfo := &model.PageInfo{
		HasNextPage: result.PageInfo.HasNextPage,
		StartCursor: func() *string {
			if len(edges) > 0 {
				return &edges[0].Cursor
			}
			return nil
		}(),
		EndCursor: func() *string {
			if len(edges) > 0 {
				return &edges[len(edges)-1].Cursor
			}
			return nil
		}(),
	}

	return &model.CommentConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	post, err := r.Resolver.PostStore.GetPostByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get post by id: %w", err)
	}
	return post, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, first *int32, after *string) (*model.PostConnection, error) {
	var firstValue int32 = 10
	if first != nil {
		firstValue = int32(*first)
	}

	result, err := r.Resolver.PostStore.GetPosts(ctx, firstValue, after)
	if err != nil {
		return nil, fmt.Errorf("get posts: %w", err)
	}

	postEdges := make([]*model.PostEdge, len(result.Edges))
	for i, edge := range result.Edges {
		postEdges[i] = &model.PostEdge{
			Cursor: edge.Cursor,
			Node:   edge.Node,
		}
	}

	var hasPreviousPage bool
	if after != nil {
		hasPreviousPage = true
	} else {
		hasPreviousPage = false
	}

	var startCursor, endCursor *string
	if len(postEdges) > 0 {
		startCursor = &postEdges[0].Cursor
		endCursor = &postEdges[len(postEdges)-1].Cursor
	}

	pageInfo := &model.PageInfo{
		HasNextPage:     result.PageInfo.HasNextPage,
		HasPreviousPage: hasPreviousPage,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}

	return &model.PostConnection{
		Edges:    postEdges,
		PageInfo: pageInfo,
	}, nil
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, id string) (*model.Comment, error) {
	comment, err := r.Resolver.CommentStore.GetCommentByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get comment by id: %w", err)
	}
	return comment, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
